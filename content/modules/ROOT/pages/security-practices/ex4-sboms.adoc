:imagesdir: ../../assets/images

= SBOMs (Software Bills of Materials)

[frame=none,grid=none,cols="1,3"]
|===
a|image::security-practices/ingredients.jpeg[]
a|
As explained earlier in this chapter, SBOMs are basically the artifact "ingredients list", listing all contained packages and components, as well as license information.

Creating SBOMs as part of the build process is not only a good security practice (for all the reasons outlined in the introduction to this chapter) - as per regulations, they are also becoming mandatory for selling software to government agencies.

2+a|
[TIP]
====
Since we are naturally following our own recommendations, Red Hat provides SBOMs for all Red Hat artifacts https://security.access.redhat.com/data/sbom/beta/spdx/[here^] as outlined in https://www.redhat.com/en/blog/future-red-hat-security-data[this article^]. 

The delivery method (all "dumped" into a huge S3 bucket that is made available to customers) is still _beta_. The security team is working on easier methods for our customer's consumption needs of Red Hat SBOMs.
====
|===

== Creating SBOMs

With that said - when we create artifacts, we also want to create SBOMs of these artifacts, typically as part of our CI toolchain. 

[NOTE]
====
Just as a side note - talking to customers, we know that many customers are already creating SBOMs in their toolchain. *BUT* the majority of customers is just creating SBOMs to "tick a regulatory box" - they are not leveraging the valuable information contained in them. They just file it away somewhere, "just in case we need it".

With tools such as Trusted Profile Analyzer (TPA), we can _use_ that information, identifying the "blast radius" if a vulnerability is identified and informing remediation efforts.

However, TPA itself doesn't create SBOMs and as long as the SBOMs are in SPDX or CycloneDX format will consume them, regardless how they were created. 

TPA 2.1 accepts CycloneDX versions 1.3, 1.4, 1.5 and 1.6, and System Package Data Exchange (SPDX) versions 2.2, and 2.3 in `.json` format
====

=== `syft`

As an Open Source solution for customers who don't have any means of creating SBOMs today, we recommend using `syft`: 

*Syft* is an open-source CLI tool and library that generates Software Bill of Materials (SBOMs) from container images, filesystems, and archives. It provides detailed visibility into packages, dependencies, and components within software artifacts.

*Origin & Development*
Syft was created and is sponsored by Anchore, a software supply chain security company, and is released under the Apache 2.0 License. The tool was designed to address the growing need for automated SBOM generation in cloud-native environments.

*Key Capabilities*
- Supports multiple container image formats (OCI, Docker, Singularity)
- Generates SBOMs in multiple standard formats including SPDX, CycloneDX, and Syft's native format
- Deep inspection capabilities that can identify dependencies nested multiple levels deep

==== *Using `syft`*

To understand what `syft` is doing, simply run `syft $IMAGE` and it will download the image from the registry and catalogue it. 

(_First, we're checking that the `$IMAGE` variable for our example image still exists - also, the `copy-image-to-quay.sh` script creates a `dockerconfig` to login to Quay_)

[source,bash,role=execute,subs=attributes+]
----
cd /workspace/l3-enablement-helpers/security-concepts
if [ -z "${IMAGE}" ]; then
    source ./copy-image-to-quay.sh
fi
echo "\$IMAGE is: $IMAGE"
syft $IMAGE
----

You can see below that `syft` not only parsed the image and its contents, but also the java application that was packaged inside it, as it identified the `smallrye-*` components that were used as dependencies.

[source,console]
----
syft $IMAGE
 ✔ Parsed image                                                                                                    sha256:771d0be00ec2b488e35925f2a9bfe27aa013afaedc40950f9c54430ef524a5c4 
 ✔ Cataloged contents                                                                                                     5c50daa8cf06e7c36854343ccc31a99aecc10167d391f2a1d3cc048b63bd29ee 
   ├── ✔ Packages                        [414 packages]  
   ├── ✔ Executables                     [826 executables]  
   ├── ✔ File digests                    [6,179 files]  
   └── ✔ File metadata                   [6,179 locations]  
NAME                                        VERSION                                          TYPE                          
alsa-lib                                    1.2.5-4.el8                                      rpm                           
aopalliance                                 1.0                                              java-archive                  
aopalliance                                 1.0-20.module+el8.3.0+6804+157bd82e              rpm          
[...]
smallrye-mutiny-vertx-auth-common           2.24.1                                           java-archive                  
smallrye-mutiny-vertx-bridge-common         2.24.1                                           java-archive                  
smallrye-mutiny-vertx-core                  2.24.1                                           java-archive                  
smallrye-mutiny-vertx-runtime               2.24.1                                           java-archive                  
smallrye-mutiny-vertx-uri-template          2.24.1                                           java-archive  
[...]
xorg-x11-fonts-Type1                        7.5-19.el8                                       rpm                           
xz-libs                                     5.2.4-3.el8                                      rpm                           
zlib                                        1.2.11-17.el8                                    rpm           
----

To get a full report in CycloneDX or SPDX format, we have to specify the format and direct it to a file:

[source,bash,role=execute,subs=attributes+]
----
syft $IMAGE --enrich all --output cyclonedx-json=demo-image-sbom.json
----

[NOTE]
====
We have added `--enrich all` here. Syft can query e.g. maven central for additional information, such as license information for packages. Especially when it comes to security, "more is better" - so the more information we can get, the better.

We will upload and manage SBOMs in xref:tssc-tpa.adoc[Module 8: Trusted Software Supply Chain with TPA] but if you'd like to take a quick look, we'll have to format it (`jq`) and make it accessible (`less`). 

*HINT* Exit `less` with kbd:[q] or kbd:[Q]

[source,bash,role=execute,subs=attributes+]
----
cat demo-image-sbom.json | jq | less
----

====


=== `roxctl`

*roxctl* is a command-line interface (CLI) for running commands on Red Hat Advanced Cluster Security for Kubernetes (RHACS), a comprehensive Kubernetes-native security platform. While roxctl supports various security operations, version 4.7 introduced SBOM generation capabilities as a Technology Preview feature.

From Red Hat Advanced Cluster Security 4.7, users can generate SBOMs from the command line or through the user interface. SBOMs can be generated from Scanner V4 image scans via the UI, CLI (`roxctl image sbom`), and API (`/api/v1/images/sbom`). Currently, only scans executed via Central are supported, with delegated scanning planned for future releases.

*Context*

The https://www.redhat.com/en/blog/red-hat-advanced-cluster-security-47-simplifies-management-enhances-workflows-and-generates-sboms[SBOM generation feature^] was introduced in response to the growing importance of SBOMs for supply chain security, especially in light of the NIST Executive Order from 2021. The `roxctl` tool integrates into CI/CD pipelines for automated security scanning, policy enforcement, and now SBOM generation alongside RHACS's broader security capabilities including vulnerability management, runtime threat detection, and compliance checking.


=== OWASP CycloneDX `maven` plugin

[IMPORTANT]
====
For *sake of completeness* we're also mentioning the CycloneDX `maven` plugin here, since it has been around since 2017 and was one of the first SBOM generators. 

However, based on its nature (a maven plugin) it can only generate SBOMs for Java artifacts. It obviously *can not* generate an SBOM for the container image that the Java Application will run in - nor for the application server (in case of `*.war` or `*.ear` files)
====

The *CycloneDX Maven plugin* generates CycloneDX Software Bill of Materials (SBOM) containing the aggregate of all direct and transitive dependencies of a project. It provides three main goals: `makeBom` (creates a BOM for each Maven module with its dependencies), `makeAggregateBom` (creates an aggregate BOM at build root with dependencies from the whole multi-modules build), and `makePackageBom` (creates a BOM for each Maven module with war or ear packaging).

*Origin & Development*

The plugin is copyright OWASP Foundation and is released under the Apache 2.0 license. The project was incepted in 2017 and has been actively maintained with regular updates,hosted on GitHub under the CycloneDX organization.

*Key Plugin Features*

By default, the BOM(s) will be attached as additional artifacts with cyclonedx classifier (can be customized by setting cyclonedx.classifier) and xml or json extension during a Maven install or deploy. The plugin offers extensive configuration options including:

- Multiple output formats (XML, JSON, or both)
- Configurable CycloneDX schema versions (currently supporting up to 1.6)
- Scope filtering (compile, provided, runtime, system, test scopes)
- Component exclusion capabilities by groupId or artifactId
- License information inclusion options
- Serial number generation for BOM tracking

Here is an example configuration that will generate a `sbom.json` in the project's `target` directory during the `maven package` phase:

[source,xml]
----
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>my-web-app</artifactId>
    <version>1.0.0</version>
    <packaging>war</packaging>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.cyclonedx</groupId>
                <artifactId>cyclonedx-maven-plugin</artifactId>
                <version>2.8.0</version>
                <configuration>
                    <!-- Project type -->
                    <projectType>application</projectType>
                    
                    <!-- CycloneDX schema version -->
                    <schemaVersion>1.6</schemaVersion>
                    
                    <!-- Include serial number for tracking -->
                    <includeBomSerialNumber>true</includeBomSerialNumber>
                    
                    <!-- Dependency scopes to include -->
                    <includeCompileScope>true</includeCompileScope>
                    <includeProvidedScope>true</includeProvidedScope>
                    <includeRuntimeScope>true</includeRuntimeScope>
                    <includeSystemScope>true</includeSystemScope>
                    <includeTestScope>false</includeTestScope>
                    
                    <!-- License details -->
                    <includeLicenseText>true</includeLicenseText>
                    
                    <!-- Output format (xml, json, or all) -->
                    <outputFormat>json</outputFormat>
                    
                    <!-- Output file name -->
                    <outputName>sbom</outputName>
                    
                    <!-- Output directory -->
                    <outputDirectory>${project.build.directory}</outputDirectory>
                </configuration>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>makePackageBom</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>
----


== Attesting SBOMs

As we have discussed in the previous exercise, an SBOM is an acceptable, even predefined attestation type that `cosign attest` accepts and `ec validate` can parse and work with:


The pre-defined predicate types are:

* slsaprovenance - SLSA Provenance v0.1
* slsaprovenance02 - SLSA Provenance v0.2  
* slsaprovenance1 - SLSA Provenance v1.0
* link - in-toto link attestation
* *_spdx - SPDX SBOM format_*
* *_spdxjson - SPDX SBOM in JSON format_*
* *_cyclonedx - CycloneDX SBOM format_*
* vuln - Vulnerability scan attestation
* openvex - OpenVEX attestation
* custom - Custom attestation (default)

We have created SBOMs of our image above, so naturally we will attest (= sign & attach) them to this image:

(_First, making sure that we still have the `$IMAGE` variable set and the `$SIGSTORE_ID_TOKEN` hasn't expired_)

[source,bash,role=execute,subs=attributes+]
----
cd /workspace/l3-enablement-helpers/security-concepts
if [ -z "${IMAGE}" ]; then
    source ./copy-image-to-quay.sh
fi
echo "\$IMAGE is: $IMAGE"
source ./get-access-token.sh
----

With these set again, attesting the SBOMs we have created earlier is as simple as

[source,bash,role=execute,subs=attributes+]
----
cosign attest --predicate demo-image-sbom.json --type cyclonedx $IMAGE
----

A `cosign tree` will now show us the SBOM attestation associated with this image:

[source,bash,role=execute,subs=attributes+]
----
cosign tree $IMAGE
----

[source,console]
----
cosign tree $IMAGE
📦 Supply Chain Security Related artifacts for an image: quay-v9q9c.apps.cluster-v9q9c.dynamic.redhatworkshops.io/l3-students/l3-rhads-demoimage:latest
└── 💾 Attestations for an image tag: quay-v9q9c.apps.cluster-v9q9c.dynamic.redhatworkshops.io/l3-students/l3-rhads-demoimage:sha256-5c50daa8cf06e7c36854343ccc31a99aecc10167d391f2a1d3cc048b63bd29ee.att
   ├── 🍒 sha256:6e1bd0b49e31237c28d14b0e90f69c532defd47685a7ea1e5920e63924adf378
   ├── 🍒 sha256:2c9aaacbdcad589845dfd37f830e878673e41aaa79a5623d23ff152c69fdb5b9
   └── 🍒 sha256:b37ce919cda4683964533680c5eec92bedc9df10a4e5f4236d68f084a70fa872
└── 🔐 Signatures for an image tag: quay-v9q9c.apps.cluster-v9q9c.dynamic.redhatworkshops.io/l3-students/l3-rhads-demoimage:sha256-5c50daa8cf06e7c36854343ccc31a99aecc10167d391f2a1d3cc048b63bd29ee.sig
   └── 🍒 sha256:853aa60efb46da00ef2fe35f9343f68c269be888ed3202274df55ff275a780c5
----

[NOTE]
====
Just from the `cosign tree` we can just tell that we now have a new attestation, but not what `type` it is.

The same image in {quay_url}/repository/l3-students/l3-rhads-demoimage?tab=tags[Quay^,window="quay"] just shows us *_one_* attestation tag (which contains all of them).

image::security-practices/quay-signed-image-attestations.png[]

Given the size of the attestation, you can guess that it contains considerable payload (instead of just a bit of text that we attested earlier) - but we can only see it when using `cosign download attestation` or `ec validate image` (when using policy rules with the latter)
====

So, with the knowledge from the previous chapter, we know that a simple `cosign download attestation` will just give us the `in-toto` "envelope" with the "Statement" as base64 encoded `payload`.

If we want to browse what we have, we need to go one level deeper:

*HINT* Exit `less` with kbd:[q] or kbd:[Q]

[source,bash,role=execute,subs=attributes+]
----
cosign download attestation $IMAGE | jq -r '.payload' | base64 -d | jq | less
----

Instead of scrolling back and forth with `less` in a huge list of attestations, we can also check what attestation types (`predicateTypes`) we have and then only download and inspect the ones we're interested in:

[source,bash,role=execute,subs=attributes+]
----
cosign download attestation $IMAGE | jq -r '.payload' | base64 -d | jq -r '.predicateType' | sort -u
----

[source,console]
----
cosign download attestation $IMAGE | jq -r '.payload' | base64 -d | jq -r '.predicateType' | sort -u
https://cyclonedx.org/bom
https://example.com/predicate/v1
https://slsa.dev/provenance/v0.2
----

[source,bash,role=execute,subs=attributes+]
----
cosign download attestation $IMAGE --predicate-type "https://cyclonedx.org/bom" | jq -r '.payload' | base64 -d | jq | less
----

