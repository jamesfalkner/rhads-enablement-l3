
= Backstage Concepts

{product_rhdh_name}, and internal developer portals in general, can be thought of as a modular system where you aggregate and display data related to the software within an organization.

The core features of {product_rhdh_name} are the:

* Software Catalog
* Software Templates
* TechDocs
* Kubernetes Integration
* Dynamic Plugins
* Role-Based Access Control (RBAC)

== Software Templates

Software Templates have been referred to as "Golden Paths" in the past. These templates are designed and curated by platform engineers to provide a starting point for new software components that adhere to best practices within an organization. Templates can also be used to patch and update existing source code repositories, and provide general automation and self-service for developer chores.

In-depth guides and examples of Software Templates are provided in later modules.

== Software Catalog

The Software Catalog is a centralized asset tracker for all of the software in an organization. It stores and tracks *Entities*:

* Components: Units of software, e.g. microservices, websites, libraries.
* Resources: Databases, S3 buckets, brokers.
* APIs: Represent interfaces such as REST, gRPC, and GraphQL APIs.
* Systems: Collections of Components that make up an application or platform.
* Domains: A higher-level grouping of Systems and Entities.
* User: Individual users that are part of an organization.
* Group: Groups of Users.

NOTE: Custom Entity types can be defined and added to the Software Catalog using plugins. We'll talk more about on plugins in subsequent sections.

Entities are typically imported and synchronized in one of three ways:

. Using plugins that automatically find and import them.
. Manually registering entities via the UI by providing a link to a repository containing them.
. Declaring them in the Backstage configuration.

In all cases, the Entities will be synchronized on a regular schedule to ensure the information in the Software Catalog remains up to date. You'll utilize all three methods throughout this workshop.

If Entity information is stored in a Git repository, the convention is to place them in a *catalog-info.yaml*. This file will look similar to the following example, albeit with changes relevant to the entity being described:

```yaml
apiVersion: backstage.io/v1alpha1
kind: Component
metadata:
  name: my-amazing-microservice
  description: A microservice written to do amazing things

  # Annotations are typically used to provide extra context to plugins, e.g TechDocs
  annotations:
    # Tells the TechDocs plugin where to find documentation sources. In this case
    # "dir:." means in the root of the repo containing this catalog-info.yaml
    backstage.io/techdocs-ref: dir:.

  # Arbitrary list of string that can be used to filter Entities in the Software Catalog
  tags:
    - docs

spec:
  type: Documentation
  lifecycle: development

  # Reference to the User or Group Entity that is responsible this Component
  owner: "pe1"
```

Users and Groups can be specified as owners of other Entities. If this seems abstract, don't worry, you'll see it in definitive terms shortly. A well curated Software Catalog enables developers to find API documentation and teams that are responsible for the Components powering those APIs, for example.

== Plugins

Backstage - and by extension {product_rhdh_name} - supports the concept of plugins. Utilizing plugins is a critical part of enabling the desired functionality for an IDP based on Backstage.

=== Why a Plugin Architecture?

==== Modularity and Extensibility
You can add or modify features without altering the core Backstage application. This modular approach makes it easier to extend functionality as needs evolve. Additionally, you can deploy the updates or new features independently of the main Backstage codebase, reducing the risks and efforts associated with maintaining and updating the platform.

==== Customization
You can tailor Backstage to fit specific workflows and use cases, enhancing the overall user experience.

==== Faster Iteration
You can create and test new features more rapidly as plugins, encouraging experimentation and enabling you to quickly iterate based on feedback.

==== Improved Collaboration
You can share plugins across teams or even externally. This sharing can foster collaboration and reduce duplication of effort, as well as help establish best practices across an organization.

==== Scalability
As organizations grow, their needs become complex. Plugins enable Backstage to scale alongside such complex needs, accommodating an increasing number of users and services.

==== Ecosystem Growth
Fostering the development of plugins can create a dynamic ecosystem around Backstage. This community can contribute to plugins that cater to different needs, thereby enhancing the platform.

==== Security and Compliance
You can develop plugins with specific security and compliance requirements in mind, ensuring that Backstage installations meet the necessary standards without compromising the core application.

=== Plugins with Upstream Backstage 

Currently, running an instance of upstream Backstage and adding plugins requires a platform engineer to:

. Create a Backstage project using Node.js and npm.
. Manage new releases and updates via Backstage CLI.
. Install plugin(s) from npm.
. Edit the Backstage React and Node.js source code to load plugins, and add customizations.
. Test their changes.
. Build a container image and deploy it.

This is a tedious and time consuming process that requires JavaScript expertise and an end-to-end SDLC for releasing your new version of Backstage

=== Dynamic Plugins in {product_rhdh_name}

The ability to load plugins dynamically is a value added feature included in {product_rhdh_name} that's currently unavailable in upstream Backstage - you can read more about it in the https://docs.redhat.com/en/documentation/red_hat_developer_hub/1.6/html/introduction_to_plugins/index#con-rhdh-plugins[{product_rhdh_name} documentation^, window="content"]. 

The dynamic plugin support in {product_rhdh_name} means that new plugins can be installed without the need to edit code and rebuild the {product_rhdh_name} container image. For example, installing the https://backstage.io/docs/integrations/gitlab/discovery[GitLab plugin with upstream Backstage] requires adding a new dependency and editing your Backstage installation's source code. Then you need to rebuild and test to ensure the plugin and Backstage versions are compatible. With {product_rhdh_name} you can simply toggle plugins on or off, and they're tested and guaranteed to be compatible with your version of {product_rhdh_name}.

You'll see dynamic plugins in action shortly.

== Understanding the {product_rhdh_name} Configuration

Upstream Backstage uses an https://backstage.io/docs/conf/[app-config.yaml^, window="content"] file to define configuration values. {product_rhdh_name} is no different.

A simple Backstage configuration file looks similar to the following example:

```yaml
# Define authentication configuration (this example is for testing only!)
auth:
  providers:
    guest:
      dangerouslyAllowOutsideDevelopment: true

# Static configuration for the Software Catalog. Can be used to import
# entities on startup, and restrict the entity types that can be imported.
catalog:
  rules:
    - allow: [Component, System, API, Resource, Location, Template]
  locations:
    - type: file
      target: https://github.com/org-name/repo-name/entities.yaml

# A configuration for the TechDocs plugin. This example instructs the plugin to
# build documentation at runtime, instead of pulling prebuilt HTML from S3
techdocs:
  builder: 'local'
  publisher:
    type: 'local'
  generator:
    runIn: local
```

You'll be using the {product_rhdh_name} operator to install and manage a Backstage instance - this means your *app-config.yaml* will be stored in a https://kubernetes.io/docs/concepts/configuration/configmap/[ConfigMap on OpenShift].

Time to get started - proceed to the next section to deploy a basic {product_rhdh_name} instance.